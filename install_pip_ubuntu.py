#!/usr/bin/env python3
"""
install_pip_ubuntu.py - Python 3 Pip Installer Generator for Ubuntu

This script generates a shell script to install pip for Python 3 on Ubuntu systems
and optionally executes it. The generated shell script uses apt-get to install
python3-pip package.

Usage:
    python3 install_pip_ubuntu.py [OPTIONS]

Options:
    -h, --help          Show this help message and exit
    -r, --run           Generate and execute the shell script immediately
    -o, --output FILE   Specify output filename (default: install_pip.sh)
    -v, --verbose       Enable verbose output

Examples:
    python3 install_pip_ubuntu.py                    # Generate install_pip.sh only
    python3 install_pip_ubuntu.py --run              # Generate and execute
    python3 install_pip_ubuntu.py -o custom.sh       # Generate with custom filename
    python3 install_pip_ubuntu.py --run --verbose    # Generate, execute with verbose output

Author: Generated script for Ubuntu pip installation
"""

import argparse
import os
import stat
import subprocess
import sys
from pathlib import Path


class Colors:
    """ANSI color codes for terminal output"""
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


def print_colored(message, color=Colors.RESET):
    """Print colored message to stdout"""
    print(f"{color}{message}{Colors.RESET}")


def generate_pip_install_script(output_file="install_pip.sh", verbose=False):
    """
    Generate a shell script to install pip for Python 3 on Ubuntu.
    
    Args:
        output_file (str): Name of the output shell script file
        verbose (bool): Enable verbose output
    
    Returns:
        str: Path to the generated shell script
    """
    
    # Shell script content
    shell_script_content = """#!/bin/bash
# install_pip.sh - Install pip for Python 3 on Ubuntu
# Generated by install_pip_ubuntu.py
#
# This script installs pip for Python 3 using apt-get package manager
# Requires sudo privileges to install system packages

set -e  # Exit on any error

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${BLUE}[HEADER]${NC} $1"
}

# Check if running on Ubuntu
if ! command -v apt-get &> /dev/null; then
    print_error "This script is designed for Ubuntu systems with apt-get package manager."
    print_error "apt-get command not found. Exiting."
    exit 1
fi

# Check if running as root or with sudo
if [[ $EUID -ne 0 ]] && ! sudo -n true 2>/dev/null; then
    print_warning "This script requires sudo privileges to install packages."
    print_status "You may be prompted for your password."
fi

print_header "Starting pip installation for Python 3 on Ubuntu"

# Update package list
print_status "Updating package list..."
if sudo apt-get update; then
    print_status "Package list updated successfully."
else
    print_error "Failed to update package list."
    exit 1
fi

# Install python3-pip
print_status "Installing python3-pip package..."
if sudo apt-get install -y python3-pip; then
    print_status "python3-pip installed successfully."
else
    print_error "Failed to install python3-pip."
    exit 1
fi

# Verify installation
print_status "Verifying pip installation..."
if command -v pip3 &> /dev/null; then
    PIP_VERSION=$(pip3 --version)
    print_status "pip3 is installed: $PIP_VERSION"
else
    print_warning "pip3 command not found. Trying pip..."
    if command -v pip &> /dev/null; then
        PIP_VERSION=$(pip --version)
        print_status "pip is installed: $PIP_VERSION"
    else
        print_error "Neither pip3 nor pip command found after installation."
        exit 1
    fi
fi

# Optional: Update pip to latest version
print_status "Updating pip to latest version..."
if pip3 install --upgrade pip; then
    print_status "pip updated to latest version."
else
    print_warning "Failed to update pip to latest version, but pip is installed."
fi

print_header "pip installation completed successfully!"
print_status "You can now use 'pip3' or 'pip' to install Python packages."
print_status "Example: pip3 install requests"
"""

    try:
        script_path = Path(output_file)
        
        # Write the shell script
        with open(script_path, 'w') as f:
            f.write(shell_script_content)
        
        # Make the script executable
        current_permissions = script_path.stat().st_mode
        script_path.chmod(current_permissions | stat.S_IEXEC)
        
        if verbose:
            print_colored(f"Generated shell script: {script_path.absolute()}", Colors.GREEN)
            print_colored(f"Script size: {script_path.stat().st_size} bytes", Colors.BLUE)
            print_colored("Script is executable", Colors.GREEN)
        
        return str(script_path.absolute())
        
    except Exception as e:
        print_colored(f"Error generating shell script: {e}", Colors.RED)
        return None


def execute_shell_script(script_path, verbose=False):
    """
    Execute the generated shell script.
    
    Args:
        script_path (str): Path to the shell script to execute
        verbose (bool): Enable verbose output
    
    Returns:
        bool: True if execution was successful, False otherwise
    """
    
    if not os.path.exists(script_path):
        print_colored(f"Script not found: {script_path}", Colors.RED)
        return False
    
    if not os.access(script_path, os.X_OK):
        print_colored(f"Script is not executable: {script_path}", Colors.RED)
        return False
    
    try:
        print_colored(f"Executing shell script: {script_path}", Colors.YELLOW)
        print_colored("=" * 50, Colors.BLUE)
        
        # Execute the script
        result = subprocess.run(
            [script_path],
            check=True,
            text=True,
            capture_output=False  # Show output in real-time
        )
        
        print_colored("=" * 50, Colors.BLUE)
        print_colored("Shell script execution completed successfully!", Colors.GREEN)
        
        if verbose:
            print_colored(f"Exit code: {result.returncode}", Colors.BLUE)
        
        return True
        
    except subprocess.CalledProcessError as e:
        print_colored("=" * 50, Colors.BLUE)
        print_colored(f"Shell script execution failed with exit code: {e.returncode}", Colors.RED)
        return False
    except Exception as e:
        print_colored(f"Error executing shell script: {e}", Colors.RED)
        return False


def main():
    """Main function to handle command-line arguments and execute the script"""
    
    parser = argparse.ArgumentParser(
        description="Generate and optionally execute a shell script to install pip for Python 3 on Ubuntu",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                    Generate install_pip.sh only
  %(prog)s --run              Generate and execute the script
  %(prog)s -o custom.sh       Generate with custom filename
  %(prog)s --run --verbose    Generate, execute with verbose output
        """
    )
    
    parser.add_argument(
        '-r', '--run',
        action='store_true',
        help='Generate and execute the shell script immediately'
    )
    
    parser.add_argument(
        '-o', '--output',
        default='install_pip.sh',
        help='Specify output filename (default: install_pip.sh)'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    
    args = parser.parse_args()
    
    # Print header
    print_colored("=" * 60, Colors.BLUE)
    print_colored("Python 3 Pip Installer Generator for Ubuntu", Colors.BOLD)
    print_colored("=" * 60, Colors.BLUE)
    
    # Generate the shell script
    print_colored("Step 1: Generating shell script...", Colors.YELLOW)
    script_path = generate_pip_install_script(args.output, args.verbose)
    
    if script_path is None:
        print_colored("Failed to generate shell script. Exiting.", Colors.RED)
        sys.exit(1)
    
    print_colored(f"✓ Shell script generated: {args.output}", Colors.GREEN)
    
    # Execute the script if requested
    if args.run:
        print_colored("Step 2: Executing shell script...", Colors.YELLOW)
        
        # Confirm execution
        try:
            confirm = input("\nDo you want to execute the script? This will install pip using sudo (y/N): ")
            if confirm.lower() not in ['y', 'yes']:
                print_colored("Script execution cancelled by user.", Colors.YELLOW)
                print_colored(f"You can run the script later with: ./{args.output}", Colors.BLUE)
                return
        except KeyboardInterrupt:
            print_colored("\nScript execution cancelled by user.", Colors.YELLOW)
            return
        
        success = execute_shell_script(script_path, args.verbose)
        
        if success:
            print_colored("✓ Script executed successfully!", Colors.GREEN)
        else:
            print_colored("✗ Script execution failed.", Colors.RED)
            sys.exit(1)
    else:
        print_colored(f"Shell script ready: {args.output}", Colors.GREEN)
        print_colored(f"To execute: ./{args.output}", Colors.BLUE)
    
    print_colored("=" * 60, Colors.BLUE)
    print_colored("Done!", Colors.GREEN)


if __name__ == "__main__":
    main()